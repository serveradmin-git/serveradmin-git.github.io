// ----- SIZE -----
const sizeValuesForOrientation = (orientation, element)=>{
    const sizeName = orientation === 'horizontal' ? 'maxWidth' : 'maxHeight';
    const overflowName = orientation === 'horizontal' ? 'overflowX' : 'overflowY';
    const measuredSize = orientation === 'horizontal' ? element.scrollWidth : element.scrollHeight;
    const toSize = `${measuredSize}px`;
    return {
        sizeName,
        overflowName,
        toSize
    };
};
export const sizeEnterAtom = ({ orientation, duration, easing, element, fromSize = '0' })=>{
    const { sizeName, overflowName, toSize } = sizeValuesForOrientation(orientation, element);
    return {
        keyframes: [
            {
                [sizeName]: fromSize,
                [overflowName]: 'hidden'
            },
            {
                [sizeName]: toSize,
                offset: 0.9999,
                [overflowName]: 'hidden'
            },
            {
                [sizeName]: 'unset',
                [overflowName]: 'unset'
            }
        ],
        duration,
        easing
    };
};
export const sizeExitAtom = ({ orientation, duration, easing, element, delay = 0, fromSize = '0' })=>{
    const { sizeName, overflowName, toSize } = sizeValuesForOrientation(orientation, element);
    return {
        keyframes: [
            {
                [sizeName]: toSize,
                [overflowName]: 'hidden'
            },
            {
                [sizeName]: fromSize,
                [overflowName]: 'hidden'
            }
        ],
        duration,
        easing,
        fill: 'both',
        delay
    };
};
// ----- WHITESPACE -----
// Whitespace animation currently includes padding, but could be extended to handle margin.
const whitespaceValuesForOrientation = (orientation)=>{
    const paddingStart = orientation === 'horizontal' ? 'paddingLeft' : 'paddingTop';
    const paddingEnd = orientation === 'horizontal' ? 'paddingRight' : 'paddingBottom';
    return {
        paddingStart,
        paddingEnd
    };
};
// Because a height of zero does not eliminate padding,
// we will create keyframes to animate it to zero.
// TODO: consider collapsing margin, perhaps as an option.
export const whitespaceEnterAtom = ({ orientation, duration, easing })=>{
    const { paddingStart, paddingEnd } = whitespaceValuesForOrientation(orientation);
    return {
        keyframes: [
            {
                [paddingStart]: '0',
                [paddingEnd]: '0',
                offset: 0
            }
        ],
        duration,
        easing
    };
};
export const whitespaceExitAtom = ({ orientation, duration, easing, delay = 0 })=>{
    const { paddingStart, paddingEnd } = whitespaceValuesForOrientation(orientation);
    return {
        keyframes: [
            {
                [paddingStart]: '0',
                [paddingEnd]: '0',
                offset: 1
            }
        ],
        duration,
        easing,
        fill: 'forwards',
        delay
    };
};
// ----- OPACITY -----
export const opacityEnterAtom = ({ duration, easing, delay = 0, fromOpacity = 0, toOpacity = 1 })=>({
        keyframes: [
            {
                opacity: fromOpacity
            },
            {
                opacity: toOpacity
            }
        ],
        duration,
        easing,
        delay,
        fill: 'both'
    });
export const opacityExitAtom = ({ duration, easing, fromOpacity = 0, toOpacity = 1 })=>({
        keyframes: [
            {
                opacity: toOpacity
            },
            {
                opacity: fromOpacity
            }
        ],
        duration,
        easing
    });
