{"version":3,"sources":["../src/components/Virtualizer/useVirtualizer.ts"],"sourcesContent":["import type { ReactNode } from 'react';\nimport type { VirtualizerProps, VirtualizerState } from './Virtualizer.types';\n\nimport { useEffect, useRef, useCallback, useImperativeHandle, useState, useReducer } from 'react';\nimport { useIntersectionObserver } from '../../hooks/useIntersectionObserver';\nimport { useVirtualizerContextState_unstable } from '../../Utilities';\nimport { slot, useTimeout } from '@fluentui/react-utilities';\nimport { flushSync } from 'react-dom';\n\nexport function useVirtualizer_unstable(props: VirtualizerProps): VirtualizerState {\n  'use no memo';\n\n  const {\n    itemSize,\n    numItems,\n    virtualizerLength,\n    children: renderChild,\n    getItemSize,\n    bufferItems = Math.round(virtualizerLength / 4.0),\n    bufferSize = Math.floor(bufferItems / 2.0) * itemSize,\n    axis = 'vertical',\n    reversed = false,\n    virtualizerContext,\n    onRenderedFlaggedIndex,\n    imperativeVirtualizerRef,\n    containerSizeRef,\n    scrollViewRef,\n    enableScrollLoad,\n    updateScrollPosition,\n  } = props;\n\n  /* The context is optional, it's useful for injecting additional index logic, or performing uniform state updates*/\n  const _virtualizerContext = useVirtualizerContextState_unstable(virtualizerContext);\n\n  // We use this ref as a constant source to access the virtualizer's state imperatively\n  const actualIndexRef = useRef<number>(_virtualizerContext.contextIndex);\n\n  const flaggedIndex = useRef<number | null>(null);\n  const actualIndex = _virtualizerContext.contextIndex;\n\n  // Just in case our ref gets out of date vs the context during a re-render\n  if (_virtualizerContext.contextIndex !== actualIndexRef.current) {\n    actualIndexRef.current = _virtualizerContext.contextIndex;\n  }\n  const setActualIndex = useCallback(\n    (index: number) => {\n      actualIndexRef.current = index;\n      _virtualizerContext.setContextIndex(index);\n    },\n    [_virtualizerContext],\n  );\n\n  // Store ref to before padding element\n  const beforeElementRef = useRef<HTMLElement | null>(null);\n\n  // Store ref to before padding element\n  const afterElementRef = useRef<HTMLElement | null>(null);\n\n  // We need to store an array to track dynamic sizes, we can use this to incrementally update changes\n  const childSizes = useRef<number[]>(new Array<number>(getItemSize ? numItems : 0));\n\n  /* We keep track of the progressive sizing/placement down the list,\n  this helps us skip re-calculations unless children/size changes */\n  const childProgressiveSizes = useRef<number[]>(new Array<number>(getItemSize ? numItems : 0));\n  if (virtualizerContext?.childProgressiveSizes) {\n    virtualizerContext.childProgressiveSizes.current = childProgressiveSizes.current;\n  }\n\n  // The internal tracking REF for child array (updates often).\n  const childArray = useRef<ReactNode[]>(new Array(virtualizerLength));\n\n  const populateSizeArrays = () => {\n    if (!getItemSize) {\n      // Static sizes, never mind!\n      return;\n    }\n\n    if (numItems !== childSizes.current.length) {\n      childSizes.current = new Array<number>(numItems);\n    }\n\n    if (numItems !== childProgressiveSizes.current.length) {\n      childProgressiveSizes.current = new Array<number>(numItems);\n      if (virtualizerContext?.childProgressiveSizes) {\n        virtualizerContext.childProgressiveSizes.current = childProgressiveSizes.current;\n      }\n    }\n\n    for (let index = 0; index < numItems; index++) {\n      childSizes.current[index] = getItemSize(index);\n      if (index === 0) {\n        childProgressiveSizes.current[index] = childSizes.current[index];\n      } else {\n        childProgressiveSizes.current[index] = childProgressiveSizes.current[index - 1] + childSizes.current[index];\n      }\n    }\n  };\n\n  const [isScrolling, setIsScrolling] = useState<boolean>(false);\n  const [setScrollTimer, clearScrollTimer] = useTimeout();\n  const scrollCounter = useRef<number>(0);\n\n  const initializeScrollingTimer = useCallback(() => {\n    if (!enableScrollLoad) {\n      // Disabled by default for reduction of render callbacks\n      return;\n    }\n    /*\n     * This can be considered the 'velocity' required to start 'isScrolling'\n     * INIT_SCROLL_FLAG_REQ: Number of renders required to activate isScrolling\n     * INIT_SCROLL_FLAG_DELAY: Amount of time (ms) before current number of renders is reset\n     *  - Maybe we should let users customize these in the future.\n     */\n    const INIT_SCROLL_FLAG_REQ = 10;\n    const INIT_SCROLL_FLAG_DELAY = 100;\n\n    scrollCounter.current++;\n    if (scrollCounter.current >= INIT_SCROLL_FLAG_REQ) {\n      setIsScrolling(true);\n    }\n    clearScrollTimer();\n    setScrollTimer(() => {\n      setIsScrolling(false);\n      scrollCounter.current = 0;\n    }, INIT_SCROLL_FLAG_DELAY);\n  }, [clearScrollTimer, setScrollTimer, enableScrollLoad]);\n\n  useEffect(() => {\n    initializeScrollingTimer();\n  }, [actualIndex, initializeScrollingTimer]);\n\n  const updateChildRows = useCallback(\n    (newIndex: number) => {\n      if (numItems === 0) {\n        /* Nothing to virtualize */\n        return;\n      }\n\n      /*\n        We reset the array every time to ensure children are re-rendered\n        This function should only be called when update is nessecary\n       */\n      childArray.current = new Array(virtualizerLength);\n      const _actualIndex = Math.max(newIndex, 0);\n      const end = Math.min(_actualIndex + virtualizerLength, numItems);\n      for (let i = _actualIndex; i < end; i++) {\n        childArray.current[i - _actualIndex] = renderChild(i, isScrolling);\n      }\n    },\n    [isScrolling, numItems, renderChild, virtualizerLength],\n  );\n\n  const updateCurrentItemSizes = useCallback(\n    (newIndex: number) => {\n      if (!getItemSize) {\n        // Static sizes, not required.\n        return;\n      }\n      // We should always call our size function on index change (only for the items that will be rendered)\n      // This ensures we request the latest data for incoming items in case sizing has changed.\n      const endIndex = Math.min(newIndex + virtualizerLength, numItems);\n      const startIndex = Math.max(newIndex, 0);\n\n      let didUpdate = false;\n      for (let i = startIndex; i < endIndex; i++) {\n        const newSize = getItemSize(i);\n        if (newSize !== childSizes.current[i]) {\n          childSizes.current[i] = newSize;\n          didUpdate = true;\n        }\n      }\n\n      if (didUpdate) {\n        // Update our progressive size array\n        for (let i = startIndex; i < numItems; i++) {\n          const prevSize = i > 0 ? childProgressiveSizes.current[i - 1] : 0;\n          childProgressiveSizes.current[i] = prevSize + childSizes.current[i];\n        }\n      }\n    },\n    [getItemSize, numItems, virtualizerLength],\n  );\n\n  const batchUpdateNewIndex = useCallback(\n    (index: number) => {\n      // Local updates\n      updateChildRows(index);\n      updateCurrentItemSizes(index);\n\n      // State setters\n      setActualIndex(index);\n    },\n    [setActualIndex, updateChildRows, updateCurrentItemSizes],\n  );\n\n  const findIndexRecursive = useCallback(\n    (scrollPos: number, lowIndex: number, highIndex: number): number => {\n      if (lowIndex > highIndex) {\n        // We shouldn't get here - but no-op the index if we do.\n        return actualIndex;\n      }\n      const midpoint = Math.floor((lowIndex + highIndex) / 2);\n      const iBefore = Math.max(midpoint - 1, 0);\n      const iAfter = Math.min(midpoint + 1, childProgressiveSizes.current.length - 1);\n      const indexValue = childProgressiveSizes.current[midpoint];\n      const afterIndexValue = childProgressiveSizes.current[iAfter];\n      const beforeIndexValue = childProgressiveSizes.current[iBefore];\n      if (scrollPos <= afterIndexValue && scrollPos >= beforeIndexValue) {\n        /* We've found our index - if we are exactly matching before/after index that's ok,\n      better to reduce checks if it's right on the boundary. */\n        return midpoint;\n      }\n\n      if (indexValue > scrollPos) {\n        return findIndexRecursive(scrollPos, lowIndex, midpoint - 1);\n      } else {\n        return findIndexRecursive(scrollPos, midpoint + 1, highIndex);\n      }\n    },\n    [actualIndex],\n  );\n\n  const getIndexFromSizeArray = useCallback(\n    (scrollPos: number): number => {\n      /* Quick searches our progressive height array */\n      if (\n        scrollPos === 0 ||\n        childProgressiveSizes.current.length === 0 ||\n        scrollPos <= childProgressiveSizes.current[0]\n      ) {\n        // Check start\n        return 0;\n      }\n\n      if (scrollPos >= childProgressiveSizes.current[childProgressiveSizes.current.length - 1]) {\n        // Check end\n        return childProgressiveSizes.current.length - 1;\n      }\n\n      return findIndexRecursive(scrollPos, 0, childProgressiveSizes.current.length - 1);\n    },\n    [findIndexRecursive],\n  );\n  const getIndexFromScrollPosition = useCallback(\n    (scrollPos: number) => {\n      if (!getItemSize) {\n        return Math.round(scrollPos / itemSize);\n      }\n\n      return getIndexFromSizeArray(scrollPos);\n    },\n    [getIndexFromSizeArray, getItemSize, itemSize],\n  );\n\n  const calculateTotalSize = useCallback(() => {\n    if (!getItemSize) {\n      return itemSize * numItems;\n    }\n\n    // Time for custom size calcs\n    return childProgressiveSizes.current[numItems - 1];\n  }, [getItemSize, itemSize, numItems]);\n\n  const calculateBefore = useCallback(() => {\n    const currentIndex = Math.min(actualIndex, numItems - 1);\n\n    if (!getItemSize) {\n      // The missing items from before virtualization starts height\n      return currentIndex * itemSize;\n    }\n\n    if (currentIndex <= 0) {\n      return 0;\n    }\n\n    // Time for custom size calcs\n    return childProgressiveSizes.current[currentIndex - 1];\n  }, [actualIndex, getItemSize, itemSize, numItems]);\n\n  const calculateAfter = useCallback(() => {\n    if (numItems === 0 || actualIndex + virtualizerLength >= numItems) {\n      return 0;\n    }\n\n    const lastItemIndex = Math.min(actualIndex + virtualizerLength, numItems);\n    if (!getItemSize) {\n      // The missing items from after virtualization ends height\n      const remainingItems = numItems - lastItemIndex;\n      return remainingItems * itemSize;\n    }\n\n    // Time for custom size calcs\n    return childProgressiveSizes.current[numItems - 1] - childProgressiveSizes.current[lastItemIndex - 1];\n  }, [actualIndex, getItemSize, itemSize, numItems, virtualizerLength]);\n\n  // Observe intersections of virtualized components\n  const { setObserverList } = useIntersectionObserver(\n    useCallback(\n      // TODO: exclude types from this lint rule: https://github.com/microsoft/fluentui/issues/31286\n      // eslint-disable-next-line no-restricted-globals\n      (entries: IntersectionObserverEntry[], observer: IntersectionObserver) => {\n        /* Sanity check - do we even need virtualization? */\n        if (virtualizerLength > numItems) {\n          if (actualIndex !== 0) {\n            batchUpdateNewIndex(0);\n          }\n          // No-op\n          return;\n        }\n\n        if (entries.length === 0) {\n          // No entries found, return.\n          return;\n        }\n        // Find the latest entry that is intersecting\n        const sortedEntries = entries.sort((entry1, entry2) => entry2.time - entry1.time);\n        const latestEntry = sortedEntries.find(entry => {\n          return entry.isIntersecting;\n        });\n\n        if (!latestEntry) {\n          return;\n        }\n\n        // We have to be sure our item sizes are up to date with current indexed ref before calculation\n        // Check if we still need\n        updateCurrentItemSizes(actualIndexRef.current);\n\n        const calculateOverBuffer = (): number => {\n          /**\n           * We avoid using the scroll ref scrollTop, it may be incorrect\n           * as virtualization may exist within a scroll view with other elements\n           * The benefit of using IO is that we can detect relative scrolls,\n           * so any items can be placed around the virtualizer in the scroll view\n           */\n          let measurementPos = 0;\n          if (latestEntry.target === afterElementRef.current) {\n            // Get after buffers position\n            measurementPos = calculateTotalSize() - calculateAfter();\n\n            // Get exact intersection position based on overflow size (how far into IO did we scroll?)\n            const overflowAmount =\n              axis === 'vertical' ? latestEntry.intersectionRect.height : latestEntry.intersectionRect.width;\n            // Add to original after position\n            measurementPos += overflowAmount;\n            // Ignore buffer size (IO offset)\n            measurementPos -= bufferSize;\n            // we hit the after buffer and detected the end of view, we need to find the start index.\n            measurementPos -= containerSizeRef.current ?? 0;\n\n            // Calculate how far past the window bounds we are (this will be zero if IO is within window)\n            const hOverflow = latestEntry.boundingClientRect.top - latestEntry.intersectionRect.top;\n            const hOverflowReversed = latestEntry.boundingClientRect.bottom - latestEntry.intersectionRect.bottom;\n            const wOverflow = latestEntry.boundingClientRect.left - latestEntry.intersectionRect.left;\n            const wOverflowReversed = latestEntry.boundingClientRect.right - latestEntry.intersectionRect.right;\n            const widthOverflow = reversed ? wOverflowReversed : wOverflow;\n            const heightOverflow = reversed ? hOverflowReversed : hOverflow;\n            const additionalOverflow = axis === 'vertical' ? heightOverflow : widthOverflow;\n\n            if (reversed) {\n              measurementPos += additionalOverflow;\n            } else {\n              measurementPos -= additionalOverflow;\n            }\n          } else if (latestEntry.target === beforeElementRef.current) {\n            // Get before buffers position\n            measurementPos = calculateBefore();\n\n            // Get exact intersection position based on overflow size (how far into window did we scroll IO?)\n            const overflowAmount =\n              axis === 'vertical' ? latestEntry.intersectionRect.height : latestEntry.intersectionRect.width;\n\n            // Minus from original before position\n            measurementPos -= overflowAmount;\n            // Ignore buffer size (IO offset)\n            measurementPos += bufferSize;\n            // Calculate how far past the window bounds we are (this will be zero if IO is within window)\n            const hOverflow = latestEntry.boundingClientRect.bottom - latestEntry.intersectionRect.bottom;\n            const hOverflowReversed = latestEntry.boundingClientRect.top - latestEntry.intersectionRect.top;\n            const wOverflow = latestEntry.boundingClientRect.right - latestEntry.intersectionRect.right;\n            const wOverflowReversed = latestEntry.boundingClientRect.left - latestEntry.intersectionRect.left;\n            const widthOverflow = reversed ? wOverflowReversed : wOverflow;\n            const heightOverflow = reversed ? hOverflowReversed : hOverflow;\n            const additionalOverflow = axis === 'vertical' ? heightOverflow : widthOverflow;\n\n            if (reversed) {\n              measurementPos += additionalOverflow;\n            } else {\n              measurementPos -= additionalOverflow;\n            }\n          }\n\n          return measurementPos;\n        };\n\n        // Get exact relative 'scrollTop' via IO values\n        const measurementPos = calculateOverBuffer();\n\n        const maxIndex = Math.max(numItems - virtualizerLength, 0);\n\n        const startIndex = getIndexFromScrollPosition(measurementPos) - bufferItems;\n\n        // Safety limits\n        const newStartIndex = Math.min(Math.max(startIndex, 0), maxIndex);\n        flushSync(() => {\n          // Callback to allow measure functions to check virtualizer length\n          if (newStartIndex + virtualizerLength >= numItems && actualIndex + virtualizerLength >= numItems) {\n            // We've already hit the end, no need to update state.\n            return;\n          }\n          updateScrollPosition?.(measurementPos);\n          if (actualIndex !== newStartIndex) {\n            batchUpdateNewIndex(newStartIndex);\n          }\n        });\n      },\n      [\n        actualIndex,\n        virtualizerLength,\n        axis,\n        reversed,\n        numItems,\n        bufferSize,\n        bufferItems,\n        containerSizeRef,\n        updateScrollPosition,\n        batchUpdateNewIndex,\n        calculateAfter,\n        calculateBefore,\n        calculateTotalSize,\n        getIndexFromScrollPosition,\n        updateCurrentItemSizes,\n      ],\n    ),\n    {\n      root: scrollViewRef ? scrollViewRef?.current : null,\n      rootMargin: '0px',\n      threshold: 0,\n    },\n  );\n\n  const setBeforeRef = useCallback(\n    (element: HTMLDivElement) => {\n      if (!element || beforeElementRef.current === element) {\n        return;\n      }\n      beforeElementRef.current = element;\n      const newList = [];\n\n      newList.push(beforeElementRef.current);\n\n      if (afterElementRef.current) {\n        newList.push(afterElementRef.current);\n      }\n\n      // Ensure we update array if before element changed\n      setObserverList(newList);\n    },\n    [setObserverList],\n  );\n\n  const setAfterRef = useCallback(\n    (element: HTMLDivElement) => {\n      if (!element || afterElementRef.current === element) {\n        return;\n      }\n      afterElementRef.current = element;\n      const newList = [];\n\n      if (beforeElementRef.current) {\n        newList.push(beforeElementRef.current);\n      }\n\n      newList.push(afterElementRef.current);\n\n      // Ensure we update array if after element changed\n      setObserverList(newList);\n    },\n    [setObserverList],\n  );\n\n  // Initialize the size array before first render.\n  const hasInitialized = useRef<boolean>(false);\n  const initializeSizeArray = () => {\n    if (hasInitialized.current === false) {\n      hasInitialized.current = true;\n      populateSizeArrays();\n    }\n  };\n\n  useImperativeHandle(\n    imperativeVirtualizerRef,\n    () => {\n      return {\n        progressiveSizes: childProgressiveSizes,\n        nodeSizes: childSizes,\n        setFlaggedIndex: (index: number | null) => (flaggedIndex.current = index),\n        currentIndex: actualIndexRef,\n      };\n    },\n    [childProgressiveSizes, childSizes],\n  );\n\n  // Initialization on mount - update array index to 0 (ready state).\n  // Only fire on mount (no deps).\n  useEffect(() => {\n    if (actualIndex < 0) {\n      batchUpdateNewIndex(0);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  /*\n   * forceUpdate:\n   * We only want to trigger this when scrollLoading is enabled and set to false,\n   * it will force re-render all children elements\n   */\n  const forceUpdate = useReducer(() => ({}), {})[1];\n  // If the user passes in an updated renderChild function - update current children\n  useEffect(() => {\n    if (actualIndex >= 0) {\n      updateChildRows(actualIndex);\n      if (enableScrollLoad && !isScrolling) {\n        forceUpdate();\n      }\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [renderChild, isScrolling]);\n\n  useEffect(() => {\n    // Ensure we repopulate if getItemSize callback changes\n    populateSizeArrays();\n\n    // We only run this effect on getItemSize change (recalc dynamic sizes)\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [getItemSize]);\n\n  // Effect to check flag index on updates\n  useEffect(() => {\n    if (!onRenderedFlaggedIndex || flaggedIndex.current === null) {\n      return;\n    }\n    if (actualIndex <= flaggedIndex.current && actualIndex + virtualizerLength >= flaggedIndex.current) {\n      onRenderedFlaggedIndex(flaggedIndex.current);\n      flaggedIndex.current = null;\n    }\n  }, [actualIndex, onRenderedFlaggedIndex, virtualizerLength]);\n\n  // Ensure we have run through and updated the whole size list array at least once.\n  initializeSizeArray();\n\n  if (getItemSize && (numItems !== childSizes.current.length || numItems !== childProgressiveSizes.current.length)) {\n    // Child length mismatch, repopulate size arrays.\n    populateSizeArrays();\n  }\n\n  // Ensure we recalc if virtualizer length changes\n  const maxCompare = Math.min(virtualizerLength, numItems);\n  if (childArray.current.length !== maxCompare && actualIndex + childArray.current.length < numItems) {\n    updateChildRows(actualIndex);\n  }\n\n  const isFullyInitialized = hasInitialized.current && actualIndex >= 0;\n  return {\n    components: {\n      before: 'div',\n      after: 'div',\n      beforeContainer: 'div',\n      afterContainer: 'div',\n    },\n    virtualizedChildren: childArray.current,\n    before: slot.always(props.before, {\n      defaultProps: {\n        ref: setBeforeRef,\n        role: 'none',\n      },\n      elementType: 'div',\n    }),\n    after: slot.always(props.after, {\n      defaultProps: {\n        ref: setAfterRef,\n        role: 'none',\n      },\n      elementType: 'div',\n    }),\n    beforeContainer: slot.always(props.beforeContainer, {\n      defaultProps: {\n        role: 'none',\n      },\n      elementType: 'div',\n    }),\n    afterContainer: slot.always(props.afterContainer, {\n      defaultProps: {\n        role: 'none',\n      },\n      elementType: 'div',\n    }),\n    beforeBufferHeight: isFullyInitialized ? calculateBefore() : 0,\n    afterBufferHeight: isFullyInitialized ? calculateAfter() : 0,\n    totalVirtualizerHeight: isFullyInitialized ? calculateTotalSize() : virtualizerLength * itemSize,\n    virtualizerStartIndex: actualIndex,\n    axis,\n    bufferSize,\n    reversed,\n    childSizes,\n    childProgressiveSizes,\n  };\n}\n"],"names":["useVirtualizer_unstable","props","itemSize","numItems","virtualizerLength","children","renderChild","getItemSize","bufferItems","Math","round","bufferSize","floor","axis","reversed","virtualizerContext","onRenderedFlaggedIndex","imperativeVirtualizerRef","containerSizeRef","scrollViewRef","enableScrollLoad","updateScrollPosition","_virtualizerContext","useVirtualizerContextState_unstable","actualIndexRef","useRef","contextIndex","flaggedIndex","actualIndex","current","setActualIndex","useCallback","index","setContextIndex","beforeElementRef","afterElementRef","childSizes","Array","childProgressiveSizes","childArray","populateSizeArrays","length","isScrolling","setIsScrolling","useState","setScrollTimer","clearScrollTimer","useTimeout","scrollCounter","initializeScrollingTimer","INIT_SCROLL_FLAG_REQ","INIT_SCROLL_FLAG_DELAY","useEffect","updateChildRows","newIndex","_actualIndex","max","end","min","i","updateCurrentItemSizes","endIndex","startIndex","didUpdate","newSize","prevSize","batchUpdateNewIndex","findIndexRecursive","scrollPos","lowIndex","highIndex","midpoint","iBefore","iAfter","indexValue","afterIndexValue","beforeIndexValue","getIndexFromSizeArray","getIndexFromScrollPosition","calculateTotalSize","calculateBefore","currentIndex","calculateAfter","lastItemIndex","remainingItems","setObserverList","useIntersectionObserver","entries","observer","sortedEntries","sort","entry1","entry2","time","latestEntry","find","entry","isIntersecting","calculateOverBuffer","measurementPos","target","overflowAmount","intersectionRect","height","width","hOverflow","boundingClientRect","top","hOverflowReversed","bottom","wOverflow","left","wOverflowReversed","right","widthOverflow","heightOverflow","additionalOverflow","maxIndex","newStartIndex","flushSync","root","rootMargin","threshold","setBeforeRef","element","newList","push","setAfterRef","hasInitialized","initializeSizeArray","useImperativeHandle","progressiveSizes","nodeSizes","setFlaggedIndex","forceUpdate","useReducer","maxCompare","isFullyInitialized","components","before","after","beforeContainer","afterContainer","virtualizedChildren","slot","always","defaultProps","ref","role","elementType","beforeBufferHeight","afterBufferHeight","totalVirtualizerHeight","virtualizerStartIndex"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}